// Generated by CoffeeScript 2.7.0
(function() {
  var Heap, SQRT2, Worker, backtrace, endLoc, grid, heuristic, locToClosed, locToF, locToG, locToH, locToOpen, locToParent, openList, startLoc, syncfinder_astar, worker;

  ({Worker} = require("jest-worker"));

  Heap = require("./heap");

  openList = new Heap();

  startLoc = 0;

  endLoc = 0;

  grid = null;

  locToClosed = null;

  locToOpen = null;

  locToG = null;

  locToH = null;

  locToF = null;

  locToParent = null;

  worker = null;

  SQRT2 = Math.SQRT2;

  // Manhattan distance.
  heuristic = function(dx, dy) {
    return dx + dy;
  };

  // Backtrace according to the parent records and return the path.
  // (including both start and end nodes)
  // @param {uint} node End node
  // @return the path array
  backtrace = function(node) {
    var path;
    //console.log "[syncfinder_astar::backtrace] node:#{node}"
    path = [];
    path.push(node);
    while (locToParent[node]) {
      node = locToParent[node];
      path.unshift(node);
    }
    return path;
  };

  syncfinder_astar = {
    findPathByBrickLoc: function(start, end, theGrid) {
      return syncfinder_astar.findPath(start >>> 16, start & 0xffff, end >>> 16, end & 0xffff, theGrid);
    },
    // find a path of giving x, y brick locations
    findPath: function(startX, startY, endX, endY, theGrid, allowDiagonal = false, crossCorners = 0) {
      var i, len, neighbor, neighborNode, neighbors, ng, node, nodeX, nodeY, x, y;
      // validate arguments
      if (isNaN(startX) || startX < 0 || isNaN(startY) || startY < 0 || isNaN(endX) || endX < 0 || isNaN(endY) || endY < 0 || !theGrid) {
        console.log(`ERROR [syncfinder_astar::findPath] bad arguments, startX:${startX}, startY:${startY}, endX:${endX}, endY:${endY}, theGrid:${theGrid}`);
        return null;
      }
      startLoc = startX << 16 | startY;
      endLoc = endX << 16 | endY;
      grid = theGrid;
      locToClosed = {};
      locToOpen = {};
      locToG = {};
      locToF = {};
      locToH = {};
      locToParent = {};
      //console.log "[syncfinder_astar::findPath] startX:#{startX}, startY:#{startY}, endX:#{endX}, endY:#{endY}" #,theGrid:#{theGrid.toString(startLoc, endLoc)}"

      // set the `g` and `f` value of the start node to be 0
      locToG[startLoc] = 0;
      locToF[startLoc] = 0;
      openList.reset(locToF);
      openList.push(startLoc);
      locToOpen[startLoc] = true;
      while (openList.isNotEmpty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        locToClosed[node] = true;
        if (node === endLoc) {
          //console.log "[syncfinder_astar::findPath] hit end brick"
          return backtrace(node);
        }
        // get neighbors of the current node
        nodeX = node >>> 16;
        nodeY = node & 0xffff;
        neighbors = grid.getNeighbors(nodeX, nodeY, allowDiagonal, crossCorners);
//console.log "[syncfinder_astar::findPath] process node:#{node}, x:#{nodeX}, y:#{nodeY}, neighbors:#{neighbors}"
        for (i = 0, len = neighbors.length; i < len; i++) {
          neighbor = neighbors[i];
          if (locToClosed[neighbor]) {
            //console.log "[syncfinder_astar::findPath] met closed node@#{neighbor}, x:#{neighbor >>> 16}, y:#{neighbor&0xffff}"
            continue;
          }
          x = neighbor >>> 16;
          y = neighbor & 0xffff;
          // get the distance between current node and the neighbor
          // and calculate the next g score
          ng = locToG[node] + (x === nodeX || y === nodeY ? 1 : SQRT2);
          //console.log "[syncfinder_astar::findPath] ng:#{ng}, locToOpen[neighbor]:#{locToOpen[neighbor]}, locToG[neighbor]:#{locToG[neighbor]}, node:#{node}"

          // check if the neighbor has not been inspected yet, or
          // can be reached with smaller cost from the current node
          if ((!locToOpen[neighbor]) || (ng < locToG[neighbor])) {
            locToG[neighbor] = ng;
            locToH[neighbor] = locToH[neighbor] || heuristic(Math.abs(x - endX), Math.abs(y - endY));
            locToF[neighbor] = locToG[neighbor] + locToH[neighbor];
            neighborNode = x << 16 | y;
            locToParent[neighborNode] = node;
            if (!locToOpen[neighbor]) {
              openList.push(neighborNode);
              locToOpen[neighbor] = true;
            } else {
              // the neighbor can be reached with smaller cost.
              // Since its f value has been updated, we have to
              // update its position in the open list
              openList.updateItem(neighborNode);
            }
          }
        }
      }
      // fail to find the path
      return null;
    },
    startWorker: function(opts = {}) {
      if (worker === null) {
        worker = new Worker(require.resolve('./worker.js'), {
          enableWorkerThreads: true,
          ...opts
        });
      }
      return worker;
    },
    endWorker: function() {
      return worker != null ? worker.end() : void 0;
    },
    findPathAsync: function(startX, startY, endX, endY, theGrid, allowDiagonal = false, crossCorners = 0) {
      if (!worker) {
        throw new Error("worker is not running");
      }
      return worker.findPath(startX, startY, endX, endY, theGrid, allowDiagonal, crossCorners);
    }
  };

  module.exports = syncfinder_astar;

}).call(this);
