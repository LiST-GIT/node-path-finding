// Generated by CoffeeScript 2.7.0
(function() {
  // an data representation of the map grid, on which path finding occurs
  var Grid, syncfinder_astar;

  syncfinder_astar = require("./syncfinder_astar");

  Grid = class Grid {
    // generate a map buffer from the given 2d array
    // @param {uint} width of the map
    // @param {uint} height of the map
    // @param {Array[Array]} 2D map array,  1: means blocked, 0: means walkable
    static bytesFrom2DArray(width, height, array2d) {
      var buf, byte, byteIndex, col, index, j, k, len, len1, offset, row, x, y;
      if (isNaN(width) || width <= 0 || isNaN(height) || height <= 0 || !Array.isArray(array2d)) {
        console.log(`ERROR [grid$::bytesFrom2DArray] bad arguments, width:${width}, height:${height}, array2d:${array2d}`);
        return null;
      }
      buf = Buffer.alloc(Math.ceil(width * height / 8));
      //console.log "len:#{buf.length}"
      buf.fill(255); // fill all bits as blocked
      for (y = j = 0, len = array2d.length; j < len; y = ++j) {
        row = array2d[y];
        for (x = k = 0, len1 = row.length; k < len1; x = ++k) {
          col = row[x];
          if (!Boolean(col)) { // 0: means walkable
            index = y * width + x;
            byteIndex = index >>> 3;
            offset = 7 - (index % 8); //从高位向低位写
            byte = buf[byteIndex];
            byte = byte ^ 1 << offset;
            buf[byteIndex] = byte;
          }
        }
      }
      //console.log "[grid$::bytesFrom2DArray] walkable at x:#{x}, y:#{y}, row:#{row}, index:#{index}, offset:#{offset}, byteIndex:#{byteIndex}"
      return buf;
    }

    // constructor function
    // @param {uint} width of the map grid
    // @param {uint} height of the map grid
    // @param {Buffer} bytes of the map grid,  1: means blocked, 0: means walkable
    constructor(width1, height1, bytes) {
      this.width = width1;
      this.height = height1;
      this.bytes = bytes;
      if (!(this.width > 0 && this.height > 0 && Buffer.isBuffer(this.bytes))) {
        throw new Error(`bad arguments, width:${this.width}, height:${this.height}, bytes:${this.bytes}`);
      }
      if (this.bytes.length !== Math.ceil(this.width * this.height / 8)) {
        throw new Error(`bytes length mismatch, width:${this.width}, height:${this.height}, bytes.length:${this.bytes.length}`);
      }
    }

    // Determine whether the node at the given position is walkable.
    // (Also returns false if the position is outside the grid.)
    // @param {number} x - The x coordinate of the node.
    // @param {number} y - The y coordinate of the node.
    // @return {boolean} - The walkability of the node.
    isWalkableAt(x, y) {
      var byte, bytePos, index, offset;
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) { // out bound
        return false;
      }
      index = y * this.width + x;
      bytePos = index >>> 3;
      offset = 7 - index % 8;
      byte = this.bytes[bytePos];
      // NOTE:
      //   1: means blocked, 0: means walkable
      // ty 2013-01-03
      return !Boolean(byte >>> offset & 1);
    }

    // Set whether the node on the given position is walkable.
    // NOTE: throws exception if the coordinate is not inside the grid.
    // @param {number} x - The x coordinate of the node.
    // @param {number} y - The y coordinate of the node.
    // @param {boolean} walkable - Whether the position is walkable.
    setWalkableAt(x, y, walkable) {
      var byte, bytePos, index, offset;
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) { // out bound
        return false;
      }
      index = y * this.width + x;
      bytePos = index >>> 3;
      offset = 7 - index % 8;
      byte = this.bytes[bytePos];
      if (walkable !== this.isWalkableAt(x, y)) {
        return this.bytes[bytePos] = byte ^ 1 << offset;
      }
    }

    // @return {uint[]} each uint present x(high 16 bit) and y(low 16 bit)
    // Get the neighbors of the given node.

    //     offsets      diagonalOffsets:
    //   +---+---+---+    +---+---+---+
    //   |   | 0 |   |    | 0 |   | 1 |
    //   +---+---+---+    +---+---+---+
    //   | 3 |   | 1 |    |   |   |   |
    //   +---+---+---+    +---+---+---+
    //   |   | 2 |   |    | 3 |   | 2 |
    //   +---+---+---+    +---+---+---+

    // When allowDiagonal is true, if offsets[i] is valid, then
    // diagonalOffsets[i] and
    // diagonalOffsets[(i + 1) % 4] is valid.
    // @param {uint}  x
    // @param {uint}  y
    // @param {boolean} allowDiagonal
    // @param {uint} crossCorners 0: strict 1: loose 2: free
    // @return {uint[]} a list of walkable neighbors brick loc
    getNeighbors(x, y, allowDiagonal = false, crossCorners = 0) {
      var d0, d1, d2, d3, neighbors, s0, s1, s2, s3;
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) { // out bound
        return null;
      }
      // TODO:
      //   should return null when brick is blocked?
      // ty 2013-05-05
      neighbors = [];
      // ↑
      if (this.isWalkableAt(x, y - 1)) {
        neighbors.push(x << 16 | (y - 1));
        s0 = true;
      }
      // →
      if (this.isWalkableAt(x + 1, y)) {
        neighbors.push((x + 1) << 16 | y);
        s1 = true;
      }
      // ↓
      if (this.isWalkableAt(x, y + 1)) {
        neighbors.push(x << 16 | (y + 1));
        s2 = true;
      }
      // ←
      if (this.isWalkableAt(x - 1, y)) {
        neighbors.push((x - 1) << 16 | y);
        s3 = true;
      }
      if (!allowDiagonal) {
        return neighbors;
      }
      if (crossCorners === 2) {
        d0 = true;
        d1 = true;
        d2 = true;
        d3 = true;
      } else if (crossCorners === 1) {
        d0 = s3 || s0;
        d1 = s0 || s1;
        d2 = s1 || s2;
        d3 = s2 || s3;
      } else {
        d0 = s3 && s0;
        d1 = s0 && s1;
        d2 = s1 && s2;
        d3 = s2 && s3;
      }
      // ↖
      if (d0 && this.isWalkableAt(x - 1, y - 1)) {
        neighbors.push((x - 1) << 16 | (y - 1));
      }
      // ↗
      if (d1 && this.isWalkableAt(x + 1, y - 1)) {
        neighbors.push((x + 1) << 16 | (y - 1));
      }
      // ↘
      if (d2 && this.isWalkableAt(x + 1, y + 1)) {
        neighbors.push((x + 1) << 16 | (y + 1));
      }
      // ↙
      if (d3 && this.isWalkableAt(x - 1, y + 1)) {
        neighbors.push((x - 1) << 16 | (y + 1));
      }
      return neighbors;
    }

    // @return {uint} a walkable brick location
    getARandomWalkableBrick() {
      var x, y;
      while (true) {
        x = (Math.random() * this.width) >>> 0;
        y = (Math.random() * this.height) >>> 0;
        if (this.isWalkableAt(x, y)) {
          return x << 16 | y;
        }
      }
    }

    getARandomWalkable() {
      var x, y;
      while (true) {
        x = (Math.random() * this.width) >>> 0;
        y = (Math.random() * this.height) >>> 0;
        if (this.isWalkableAt(x, y)) {
          return {x, y};
        }
      }
    }

    findPath(startX, startY, endX, endY, allowDiagonal = false, crossCorners = 0) {
      return syncfinder_astar.findPath(startX, startY, endX, endY, this, allowDiagonal, crossCorners);
    }

    findPathSync(startX, startY, endX, endY, allowDiagonal = false, crossCorners = 0) {
      return syncfinder_astar.findPath(startX, startY, endX, endY, this, allowDiagonal, crossCorners);
    }

    findPathAsync(startX, startY, endX, endY, allowDiagonal = false, crossCorners = 0) {
      return syncfinder_astar.findPathAsync(startX, startY, endX, endY, this, allowDiagonal, crossCorners);
    }

    // print out the block data for human inspection
    // @param {uint} startLoc the start brick loc
    // @param {uint} endLoc the end brick loc
    // @param {uint[]} path array of point
    // @return {String} a string describe this instance
    toString(startLoc, endLoc, path) {
      var arr, brickLoc, i, j, k, l, len, markpoints, ref, ref1, result, x, y;
      markpoints = {};
      if (Array.isArray(path)) {
        for (i = j = 0, len = path.length; j < len; i = ++j) {
          brickLoc = path[i];
          markpoints[brickLoc] = i % 10;
        }
      }
      if (!isNaN(startLoc)) {
        markpoints[startLoc] = "S";
      }
      if (!isNaN(endLoc)) {
        markpoints[endLoc] = "E";
      }
      result = `[Grid(width=${this.width}, height=${this.height})]\nDump: ░=walkable, ▓=blocked`;
      for (y = k = 0, ref = this.height; k < ref; y = k += 1) {
        arr = [];
        for (x = l = 0, ref1 = this.width; l < ref1; x = l += 1) {
          if (markpoints[x << 16 | y] !== void 0) {
            arr.push(markpoints[x << 16 | y]);
          } else {
            arr.push(this.isWalkableAt(x, y) ? "░" : "▓");
          }
        }
        result = result + `\n${arr.join('')}`;
      }
      return result;
    }

  };

  module.exports = Grid;

}).call(this);
